<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>PFSS</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>PFSS</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#sec_introduction">1. Introduction</a></li>
<li><a href="#_build_examples">2. Build examples</a></li>
<li><a href="#hardware_acceleration">3. Hardware acceleration</a>
<ul class="sectlevel2">
<li><a href="#_x86_acceleration">3.1. x86 acceleration</a></li>
<li><a href="#_arm_acceleration">3.2. ARM acceleration</a></li>
</ul>
</li>
<li><a href="#logging">4. Logging</a></li>
<li><a href="#benchmarking">5. Benchmarking</a></li>
<li><a href="#c_api">6. C API</a>
<ul class="sectlevel2">
<li><a href="#cl_pfss_set_log_file">6.1. The <code>pfss_set_log_file</code> function</a></li>
<li><a href="#cl_pfss_get_log_file">6.2. The <code>pfss_get_log_file</code> function</a></li>
<li><a href="#c_api_pfss_status">6.3. The <code>pfss_status</code> type</a></li>
<li><a href="#cl_pfss_get_status_name">6.4. The <code>pfss_get_status_name</code> function</a></li>
<li><a href="#c_api_pfss_endianness">6.5. The <code>pfss_endianness</code> type</a></li>
<li><a href="#c_api_pfss_gen_sizes">6.6. The <code>pfss_gen_sizes</code> function</a></li>
<li><a href="#c_api_pfss_gen">6.7. The <code>pfss_gen</code> function</a></li>
<li><a href="#c_api_pfss_map_gen">6.8. The <code>pfss_map_gen</code> function</a></li>
<li><a href="#c_api_pfss_key">6.9. The <code>pfss_key</code> type</a></li>
<li><a href="#c_api_pfss_parse_key">6.10. The <code>pfss_parse_key</code> function</a></li>
<li><a href="#c_api_pfss_destroy_key">6.11. The <code>pfss_destroy_key</code> function</a></li>
<li><a href="#cl_pfss_get_domain_bits">6.12. The <code>pfss_get_domain_bits</code> function</a></li>
<li><a href="#cl_pfss_get_range_bits">6.13. The <code>pfss_get_range_bits</code> function</a></li>
<li><a href="#cl_pfss_eval">6.14. The <code>pfss_eval</code> function</a></li>
<li><a href="#c_api_PFSS_DEFINE_DIRECT_EVAL">6.15. The <code>PFSS_DEFINE_DIRECT_EVAL</code> macro</a></li>
<li><a href="#c_api_pfss_reduce_sum">6.16. The <code>pfss_reduce_sum</code> function</a></li>
<li><a href="#cl_pfss_map_eval">6.17. The <code>pfss_map_eval</code> function</a></li>
<li><a href="#cl_pfss_map_eval_reduce_sum">6.18. The <code>pfss_map_eval_reduce_sum</code> function</a></li>
<li><a href="#cl_pfss_eval_all">6.19. The <code>pfss_eval_all</code> function</a></li>
<li><a href="#cl_pfss_eval_all_sum">6.20. The <code>pfss_eval_all_sum</code> function</a></li>
<li><a href="#cl_pfss_eval_all_dot">6.21. The <code>pfss_eval_all_dot</code> function</a></li>
<li><a href="#_the_pfss_switch_db_rb_macro">6.22. The <code>PFSS_SWITCH_DB_RB</code> macro</a></li>
</ul>
</li>
<li><a href="#_using_the_java_bindings">7. Using the Java bindings</a></li>
<li><a href="#_node_js_bindings">8. Node.js bindings</a>
<ul class="sectlevel2">
<li><a href="#_general">8.1. General</a></li>
<li><a href="#_running_the_example_project_with_docker">8.2. Running the example project with Docker</a></li>
<li><a href="#_reference">8.3. Reference</a>
<ul class="sectlevel3">
<li><a href="#node_sec_pfss_reduce_sum_async">8.3.1. The <code>pfss_reduce_sum_async</code> function</a></li>
<li><a href="#node_sec_pfss_map_eval_reduce_sum_async">8.3.2. The <code>pfss_map_eval_reduce_sum_async</code> function</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="sec_introduction"><a class="anchor" href="#sec_introduction"></a><a class="link" href="#sec_introduction">1. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>PFSS is a library for function secret sharing (FSS).</p>
</div>
<div class="paragraph">
<p>The C API is defined in the
<a href="src/c_cpp/include/pfss.h"><code>src/c_cpp/include/pfss.h</code></a> file.</p>
</div>
<div class="paragraph">
<p>To build PFSS, you&#8217;ll need <code>make</code>, a C compiler, and a C++ compiler.</p>
</div>
<div class="paragraph">
<p>PFSS also currently requires CPU or library support for certain
cryptographic operations.
This can be either the AES-NI extension for x86 family CPUs, the
Cryptographic Extension for ARM family CPUs, or the
<a href="https://www.lysator.liu.se/~nisse/nettle/">Nettle library</a>.
Nettle should be readily available through most package managers.
For example, on Ubuntu, Nettle can be installed with
<code>sudo apt-get install nettle-dev</code>.
If you have AES-NI or ARM Crypto support, then Nettle is not required.
If you have none of these, then <code>make</code> will fail.</p>
</div>
<div class="paragraph">
<p>You can then build and install PFSS with the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>./configure
make
sudo make install</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to install PFSS to your system, you can replace the
<code>sudo make install</code> command with <code>make DESTDIR="$(pwd)"/tmp install</code> to
perform a staged install to a local directory <code>tmp</code>.
You can then use those files however you want.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_build_examples"><a class="anchor" href="#_build_examples"></a><a class="link" href="#_build_examples">2. Build examples</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides several examples of building and installing PFSS.
These examples will assume that we&#8217;re building an application that&#8217;s
particularly interested in <code>domain_bits</code> = 80 and <code>range_bits</code> = 16.</p>
</div>
<div class="paragraph">
<p>Building and installing on a typical x86-64 machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># Enable template optimizations only for (80,16).
echo "80 16" &gt;switch_db_rb.cfg

# Set up our compiler flags.
export CPPFLAGS="-DNDEBUG"
export CFLAGS="-O2 -march=native"
export CXXFLAGS="$CFLAGS"

# Run ./configure, ensuring that it detects AES-NI.
./configure --with-aes-ni-or-die

# Compile, run the test suite, and install.
make
make check
sudo make install</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cross compiling for Android ARMv8-A on a typical x86-64 Linux machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># Enable template optimizations only for (80,16).
echo "80 16" &gt;switch_db_rb.cfg

# Download and extract the Android NDK.
wget https://dl.google.com/android/repository/android-ndk-r21c-linux-x86_64.zip
unzip android-ndk-r21c-linux-x86_64.zip

# Set up the environment as recommended by
# &lt;https://developer.android.com/ndk/guides/other_build_systems&gt;.
export NDK=$(pwd)/android-ndk-r21c
export TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64
export TARGET=aarch64-linux-android
export API=21
export AR=$TOOLCHAIN/bin/$TARGET-ar
export AS=$TOOLCHAIN/bin/$TARGET-as
export CC=$TOOLCHAIN/bin/$TARGET$API-clang
export CXX=$TOOLCHAIN/bin/$TARGET$API-clang++
export LD=$TOOLCHAIN/bin/$TARGET-ld
export RANLIB=$TOOLCHAIN/bin/$TARGET-ranlib
export STRIP=$TOOLCHAIN/bin/$TARGET-strip

# Set up our compiler flags.
export CPPFLAGS="-DNDEBUG"
export CFLAGS="-O2 -march=armv8-a"
export CXXFLAGS="$CFLAGS"

# Run ./configure, ensuring that it detects ARM Crypto and JNI.
./configure --build x86_64-pc-linux-gnu --host $TARGET \
  --with-arm-crypto-or-die --with-jni-or-die \
  --with-cross-cflag-march-arm-crypto \
  --with-cross-cxxflag-march-arm-crypto

# Compile and do a staged install.
make
make DESTDIR=$(pwd)/staged install

# List the files of the staged install.
find staged ! -type d

# You may also need the libc++_shared.so library from the NDK:
# $NDK/sources/cxx-stl/llvm-libc++/libs/arm64-v8a/libc++_shared.so</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hardware_acceleration"><a class="anchor" href="#hardware_acceleration"></a><a class="link" href="#hardware_acceleration">3. Hardware acceleration</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>PFSS can optionally be compiled to use special CPU instructions for
increased performance.
The <code>./configure</code> step of the build system automatically detects which
of these instructions are available and enables them in the code
accordingly.
However, the detection process sometimes needs user intervention to
ensure that the instructions are being detected properly.</p>
</div>
<div class="paragraph">
<p>The terms <em>build system</em> and <em>host system</em> are generally used to refer
to the system on which you are compiling the code and the system on
which you will be running the compiled code, respectively.
This overloads the term &#8220;build system&#8221;, which is also generally used
to refer to the overall build system, but the meaning should be clear
from context.</p>
</div>
<div class="sect2">
<h3 id="_x86_acceleration"><a class="anchor" href="#_x86_acceleration"></a><a class="link" href="#_x86_acceleration">3.1. x86 acceleration</a></h3>
<div class="paragraph">
<p>For the x86 family of CPUs, there are two CPU instruction groups that
can be enabled: SSE2 and AES-NI.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re not cross compiling, <code>./configure</code> is usually able to detect
these instruction groups properly without any user intervention.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re expecting one or more of these instruction groups to be available and
you want to ensure that they&#8217;re being detected properly, you can specify
the appropriate combination of the following options when running
<code>./configure</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--with-sse2-or-die  --with-aes-ni-or-die</pre>
</div>
</div>
<div class="paragraph">
<p>When these options are specified, <code>./configure</code> will fail if the
corresponding instruction groups were not detected.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re cross compiling, the <code>--with-<em>group</em>-or-die</code> options will
make <code>./configure</code> fail by default, even if the host system supports the
corresponding instruction groups.
This happens because the detection process needs to compile and run
several small test programs, but since you&#8217;re cross compiling, it can
only compile the test programs, not run them.
In this case, you can make <code>./configure</code> assume that the appropriate
test programs would have succeeded by additionally specifying the
appropriate combination of the following options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--with-cross-cflag-msse2  --with-cross-cxxflag-msse2
--with-cross-cflag-maes   --with-cross-cxxflag-maes</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to specify <em>all</em> of the above options whose corresponding test
programs would have succeeded, as neglecting to specify some of them may
cascade and cause others to have no effect.
For example, since AES-NI cannot be available without SSE2 also being
available, neglecting to specify <code>--with-cross-cflag-msse2</code> will cause
<code>--with-cross-cflag-maes</code> to have no effect.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arm_acceleration"><a class="anchor" href="#_arm_acceleration"></a><a class="link" href="#_arm_acceleration">3.2. ARM acceleration</a></h3>
<div class="paragraph">
<p>For the ARM family of CPUs, there is one CPU instruction group that can
be enabled: ARM Crypto.</p>
</div>
<div class="paragraph">
<p>Regardless of whether you&#8217;re cross compiling, <code>./configure</code> usually
needs user intervention to detect this instruction group properly.
To do this, specify at least one of the <code>-march=&#8230;&#8203;</code> and <code>--mcpu=&#8230;&#8203;</code>
options in both <code>CFLAGS</code> and <code>CXXFLAGS</code> when running <code>./configure</code>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re expecting one or more of these instruction groups to be available and
you want to ensure that they&#8217;re being detected properly, you can specify
the appropriate combination of the following options when running
<code>./configure</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--with-arm-crypto-or-die</pre>
</div>
</div>
<div class="paragraph">
<p>When these options are specified, <code>./configure</code> will fail if the
corresponding instruction groups were not detected.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re cross compiling, the <code>--with-<em>group</em>-or-die</code> options will
make <code>./configure</code> fail by default, even if the host system supports the
corresponding instruction groups.
This happens because the detection process needs to compile and run
several small test programs, but since you&#8217;re cross compiling, it can
only compile the test programs, not run them.
In this case, you can make <code>./configure</code> assume that the appropriate
test programs would have succeeded by additionally specifying the
appropriate combination of the following options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--with-cross-cflag-march-arm-crypto  --with-cross-cxxflag-march-arm-crypto</pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to specify <em>all</em> of the above options whose corresponding test
programs would have succeeded, as neglecting to specify some of them may
cascade and cause others to have no effect.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a><a class="link" href="#logging">4. Logging</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>PFSS includes a logging layer that can be enabled at build time by
specifying the <code>--with-logging</code> option to <code>./configure</code>.
When logging is enabled and a log file has been set by calling the
<code><a href="#cl_pfss_set_log_file">pfss_set_log_file</a></code> function, every call to the PFSS C API will
write a line to the log file with information about the call.
Each line has the following format, which is based on the format used by
the <code><a href="https://manpages.debian.org/strace">strace</a></code> utility:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code><em>time</em> <em>func</em>(<em>args</em>) = <em>ret</em> &lt;<em>dura</em>&gt;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><em>time</em></code></dt>
<dd>
<p>The <a href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a> at which the call was made, in nanoseconds.</p>
</dd>
<dt class="hdlist1"><code><em>func</em></code></dt>
<dd>
<p>The name of the function that was called.</p>
</dd>
<dt class="hdlist1"><code><em>args</em></code></dt>
<dd>
<p>The arguments that were passed to the function.</p>
</dd>
<dt class="hdlist1"><code><em>ret</em></code></dt>
<dd>
<p>The value the function returned.</p>
</dd>
<dt class="hdlist1"><code><em>dura</em></code></dt>
<dd>
<p>The amount of time the call took, in nanoseconds.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="benchmarking"><a class="anchor" href="#benchmarking"></a><a class="link" href="#benchmarking">5. Benchmarking</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>PFSS provides a command-line utility named <code>pfss-benchmark</code> for
benchmarking the PFSS library.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="c_api"><a class="anchor" href="#c_api"></a><a class="link" href="#c_api">6. C API</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="cl_pfss_set_log_file"><a class="anchor" href="#cl_pfss_set_log_file"></a><a class="link" href="#cl_pfss_set_log_file">6.1. The <code>pfss_set_log_file</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code>FILE * pfss_set_log_file(
  FILE * log_file
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_set_log_file</code> function sets the <a href="#logging">logging</a>
destination to <code>log_file</code> and returns the previous logging destination.</p>
</div>
<div class="paragraph">
<p>A null pointer indicates logging is disabled.</p>
</div>
<div class="paragraph">
<p>If logging was not enabled at build time with
<code>./configure --with-logging</code>, getting and setting the logging
destination still behaves normally, but logging is always disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_get_log_file"><a class="anchor" href="#cl_pfss_get_log_file"></a><a class="link" href="#cl_pfss_get_log_file">6.2. The <code>pfss_get_log_file</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code>FILE * pfss_get_log_file(
  void
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_get_log_file</code> function returns the <a href="#logging">logging</a>
destination.</p>
</div>
<div class="paragraph">
<p>A null pointer indicates logging is disabled.</p>
</div>
<div class="paragraph">
<p>If logging was not enabled at build time with
<code>./configure --with-logging</code>, getting and setting the logging
destination still behaves normally, but logging is always disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_status"><a class="anchor" href="#c_api_pfss_status"></a><a class="link" href="#c_api_pfss_status">6.3. The <code>pfss_status</code> type</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef uint32_t pfss_status;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_status</code> type represents a status code of a function call.
Most PFSS functions return a <code>pfss_status</code> code.</p>
</div>
<div class="paragraph">
<p><code>pfss_status</code> is guaranteed to be an alias of <code>uint32_t</code>.</p>
</div>
<div class="paragraph">
<p>Each status code is defined as a macro that expands to an integer
constant expression that can be used in both normal code and in
preprocessor arithmetic.
In normal code, the type of the expression is <code>pfss_status</code>.</p>
</div>
<div class="paragraph">
<p>The status codes and their meanings are listed below.
Note that some meanings are more descriptive than others.
Functions generally return the most descriptive status code they can.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 (0x0) <code>PFSS_OK</code><br>
The function succeeded.</p>
</li>
<li>
<p>1 (0x1) <code>PFSS_UNKNOWN_ERROR</code><br>
The function failed.</p>
</li>
<li>
<p>2 (0x2) <code>PFSS_INVALID_ARGUMENT</code><br>
The function failed because of an invalid argument.</p>
</li>
<li>
<p>3 (0x3) <code>PFSS_NULL_POINTER</code><br>
The function failed because of an invalid argument.
In particular, an argument was incorrectly a null pointer.</p>
</li>
<li>
<p>4 (0x4) <code>PFSS_INVALID_DOMAIN</code><br></p>
</li>
<li>
<p>5 (0x5) <code>PFSS_INVALID_RANGE</code><br></p>
</li>
<li>
<p>6 (0x6) <code>PFSS_UNSUPPORTED_DOMAIN_AND_RANGE</code><br></p>
</li>
<li>
<p>7 (0x7) <code>PFSS_DOMAIN_OVERFLOW</code><br></p>
</li>
<li>
<p>8 (0x8) <code>PFSS_RANGE_OVERFLOW</code><br></p>
</li>
<li>
<p>9 (0x9) <code>PFSS_MALFORMED_KEY</code><br></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_get_status_name"><a class="anchor" href="#cl_pfss_get_status_name"></a><a class="link" href="#cl_pfss_get_status_name">6.4. The <code>pfss_get_status_name</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">char const * pfss_get_status_name(
  pfss_status status
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_get_status_name</code> function returns a pointer to a constant
string with static storage duration that holds the name of the status
code <code>status</code>.
If <code>status</code> is not a valid status code, the string will be
<code>"PFSS_UNKNOWN_STATUS"</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_endianness"><a class="anchor" href="#c_api_pfss_endianness"></a><a class="link" href="#c_api_pfss_endianness">6.5. The <code>pfss_endianness</code> type</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef uint32_t pfss_endianness;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_endianness</code> type describes the byte order of an integer value.</p>
</div>
<div class="paragraph">
<p>The endianness constants and their meanings are listed below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 (0x0) <code>PFSS_NATIVE_ENDIAN</code><br>
The native byte order of the system.</p>
</li>
<li>
<p>1 (0x1) <code>PFSS_LITTLE_ENDIAN</code><br>
Little endian byte order.</p>
</li>
<li>
<p>2 (0x2) <code>PFSS_BIG_ENDIAN</code><br>
Big endian byte order.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_gen_sizes"><a class="anchor" href="#c_api_pfss_gen_sizes"></a><a class="link" href="#c_api_pfss_gen_sizes">6.6. The <code>pfss_gen_sizes</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_gen_sizes(
  uint32_t   domain_bits,
  uint32_t   range_bits,
  uint32_t * key_blob_size,
  uint32_t * rand_buf_size
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_gen_sizes</code> function determines how big each of the key blobs
generated by the <code>pfss_gen</code> function will be for the given <code>domain_bits</code>
and <code>range_bits</code> values, and how many random bytes will be needed to
generate them.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_gen"><a class="anchor" href="#c_api_pfss_gen"></a><a class="link" href="#c_api_pfss_gen">6.7. The <code>pfss_gen</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_gen(
  uint32_t        domain_bits,
  uint32_t        range_bits,
  uint8_t const * alpha,
  uint32_t        alpha_size,
  pfss_endianness alpha_endianness,
  uint8_t const * beta,
  uint32_t        beta_size,
  pfss_endianness beta_endianness,
  uint8_t *       key1_blob,
  uint8_t *       key2_blob,
  uint8_t const * rand_buf
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_gen</code> function generates two key blobs that form a secret
sharing of the function
\(f : \{0,1\}^\mathtt{domain\_bits} \rightarrow \{0,1\}^\mathtt{range\_bits}\)
defined by \(f(\mathtt{alpha}) = \mathtt{beta}\) and \(f(x) = 0\)
everywhere else.</p>
</div>
<div class="paragraph">
<p><code>domain_bits</code> and <code>range_bits</code> should both be nonzero.</p>
</div>
<div class="paragraph">
<p><code>alpha</code> should be an unsigned integer that consists of <code>alpha_size</code> bytes in
<code>alpha_endianness</code> byte order.
The bits are ordered from least to most significant, and any bits above
the least significant <code>domain_bits</code> bits are ignored.
<code>alpha_size</code> should be nonzero.</p>
</div>
<div class="paragraph">
<p><code>beta</code> should be an unsigned integer that consists of <code>beta_size</code> bytes in
<code>beta_endianness</code> byte order.
The bits are ordered from least to most significant, and any bits above
the least significant <code>range_bits</code> bits are ignored.
<code>beta_size</code> should be nonzero.</p>
</div>
<div class="paragraph">
<p>The key blobs will be written to the <code>key1_blob</code> and <code>key2_blob</code> arrays.
The size of both arrays should be the size obtained by a call to the
<a href="#c_api_pfss_gen_sizes"><code>pfss_gen_sizes</code></a> function with the same
<code>domain_bits</code> and <code>range_bits</code> values.</p>
</div>
<div class="paragraph">
<p><code>rand_buf</code> should be an array of random bytes.
The size of the array should be the size obtained by a call to the
<a href="#c_api_pfss_gen_sizes"><code>pfss_gen_sizes</code></a> function with the same
<code>domain_bits</code> and <code>range_bits</code> values.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_map_gen"><a class="anchor" href="#c_api_pfss_map_gen"></a><a class="link" href="#c_api_pfss_map_gen">6.8. The <code>pfss_map_gen</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_map_gen(
  uint32_t        domain_bits,
  uint32_t        range_bits,
  uint8_t const * alphas,
  uint32_t        alphas_count,
  uint32_t        alpha_size,
  pfss_endianness alpha_endianness,
  uint8_t const * betas,
  uint32_t        beta_size,
  pfss_endianness beta_endianness,
  uint8_t *       key1_blobs,
  uint8_t *       key2_blobs,
  uint8_t const * rand_bufs
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_map_gen</code> function creates FSS key pairs for each of the
<code>alphas_count</code> elements of <code>alphas</code> and <code>betas</code>, storing the key pairs
inside <code>key1_blobs</code> and <code>key2_blobs</code>.
Each element of <code>alphas</code> should be an unsigned integer that consists of
<code>alpha_size</code> bytes in <code>alpha_endianness</code> byte order.
Each element of <code>betas</code> should be an unsigned integer that consists of
<code>beta_size</code> bytes in <code>beta_endianness</code> byte order.
Each element in alphas should be less than 2^domain_bits and each
element of betas should be less than 2^range_bits. As long as the
values of each element in alphas and betas are in range, alpha_size and
beta_size can be arbitrarily large or small, but they must not be zero.
<code>key1_blobs</code> and <code>key2_blobs</code> should be containers consisting of
<code>alphas_count</code> * <code>key_blob_size</code> bytes.
Similarly, <code>rand_bufs</code> should be a container consisting of
<code>alphas_count</code> * <code>rand_buf_size</code> bytes.
The function returns <code>PFSS_OK</code> upon success, or another status code upon
failure.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_key"><a class="anchor" href="#c_api_pfss_key"></a><a class="link" href="#c_api_pfss_key">6.9. The <code>pfss_key</code> type</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct pfss_key pfss_key;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_key</code> type represents a key that has been parsed from a key
blob.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_parse_key"><a class="anchor" href="#c_api_pfss_parse_key"></a><a class="link" href="#c_api_pfss_parse_key">6.10. The <code>pfss_parse_key</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_parse_key(
  pfss_key * *    p_key,
  uint8_t const * key_blob,
  uint32_t        key_blob_size
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_parse_key</code> function parses a key blob.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_destroy_key"><a class="anchor" href="#c_api_pfss_destroy_key"></a><a class="link" href="#c_api_pfss_destroy_key">6.11. The <code>pfss_destroy_key</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_destroy_key(
  pfss_key * key
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_destroy_key</code> function destroys a key.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_get_domain_bits"><a class="anchor" href="#cl_pfss_get_domain_bits"></a><a class="link" href="#cl_pfss_get_domain_bits">6.12. The <code>pfss_get_domain_bits</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_get_domain_bits(
  pfss_key const * key,
  uint32_t *       domain_bits
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_get_domain_bits</code> function sets <code>*domain_bits</code> to the number of
domain bits in <code>*key</code>.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_get_range_bits"><a class="anchor" href="#cl_pfss_get_range_bits"></a><a class="link" href="#cl_pfss_get_range_bits">6.13. The <code>pfss_get_range_bits</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_get_range_bits(
  pfss_key const * key,
  uint32_t *       range_bits
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_get_range_bits</code> function sets <code>*range_bits</code> to the number of
range bits in <code>*key</code>.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_eval"><a class="anchor" href="#cl_pfss_eval"></a><a class="link" href="#cl_pfss_eval">6.14. The <code>pfss_eval</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_eval(
  pfss_key const * key,
  uint8_t const *  x,
  uint32_t         x_size,
  pfss_endianness  x_endianness,
  uint8_t *        y,
  uint32_t         y_size,
  pfss_endianness  y_endianness
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_eval</code> function evaluates a key at a single domain element to
produce a single range element.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
</div>
<div class="sect2">
<h3 id="c_api_PFSS_DEFINE_DIRECT_EVAL"><a class="anchor" href="#c_api_PFSS_DEFINE_DIRECT_EVAL"></a><a class="link" href="#c_api_PFSS_DEFINE_DIRECT_EVAL">6.15. The <code>PFSS_DEFINE_DIRECT_EVAL</code> macro</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PFSS_DEFINE_DIRECT_EVAL(f, domain_bits, range_type) \
  static range_type f(void const * k, void const * x) { &#8230;&#8203; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PFSS_DEFINE_DIRECT_EVAL</code> macro defines a self-contained function
<code>f</code> that evaluates an unparsed key blob <code>k</code> at a domain value <code>x</code>.
<code>f</code> can be any name of your choice.
<code>domain_bits</code> should be an integer constant expression with type <code>int</code>
whose value is between 1 and 128 inclusive.
<code>range_type</code> should be either <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, or
<code>uint64_t</code>.</p>
</div>
<div class="paragraph">
<p>When calling <code>f</code>, <code>k</code> should be a key blob that was output by the
<code>pfss_gen</code> function with the same number of domain bits and range bits
as specified by <code>domain_bits</code> and <code>range_type</code>, and <code>x</code> should be an
unsigned integer that consists of
\(\lceil\mathtt{domain\_bits}/8\rceil\) bytes in little endian byte
order.
Any bits above the least significant <code>domain_bits</code> bits of <code>x</code> are
ignored.
The return value is the result of the evaluation.</p>
</div>
<div class="paragraph">
<p>The code of <code>f</code> is valid as both C and C&#43;&#43;.
However, <code>f</code> currently requires AES-NI support via the <code>-maes</code> compiler
option.
This option is normally handled by the PFSS build system, but since
you&#8217;ll be compiling <code>f</code> yourself, you&#8217;ll need to provide this option
yourself.
In the future, it may be generalized to work on other systems.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. </div>
<div class="content">
<div class="paragraph">
<p>The following code uses the <code>PFSS_DEFINE_DIRECT_EVAL</code> macro to define a
self-contained function
<code>static uint16_t my_eval(void const * k, void const * x) { &#8230;&#8203; }</code> that
evaluates an unparsed key blob <code>k</code> with 128 domain bits and 16 range
bits at a domain value <code>x</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#include &lt;pfss.h&gt;
#include &lt;stdint.h&gt;
PFSS_DEFINE_DIRECT_EVAL(my_eval, 128, uint16_t)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="c_api_pfss_reduce_sum"><a class="anchor" href="#c_api_pfss_reduce_sum"></a><a class="link" href="#c_api_pfss_reduce_sum">6.16. The <code>pfss_reduce_sum</code> function</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_reduce_sum(
  uint32_t        range_bits,
  uint8_t const * ys,
  uint32_t        ys_count,
  uint32_t        y_size,
  pfss_endianness y_endianness,
  uint8_t *       z,
  uint32_t        z_size,
  pfss_endianness z_endianness
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_reduce_sum</code> function sets <code>x</code> to the sum of the <code>ys_count</code>
elements of <code>ys</code>.
Each element of <code>ys</code> should be an unsigned integer that consists of
<code>y_size</code> bytes in <code>y_endianness</code> byte order.
The sum is taken modulo <code>2<sup>range_bits</sup></code> and output as an unsigned
integer that consists of <code>z_size</code> bytes in <code>z_endianness</code> byte order.
The function returns <code>PFSS_OK</code> upon success, or another status code upon
failure.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_map_eval"><a class="anchor" href="#cl_pfss_map_eval"></a><a class="link" href="#cl_pfss_map_eval">6.17. The <code>pfss_map_eval</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_map_eval(
  pfss_key const * key,
  uint8_t const *  xs,
  uint32_t         xs_count,
  uint32_t         x_size,
  pfss_endianness  x_endianness,
  uint8_t *        ys,
  uint32_t         y_size,
  pfss_endianness  y_endianness
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_map_eval</code> function evaluates a key over a list of domain
elements to produce a list of range elements.</p>
</div>
<div class="paragraph">
<p><code>xs</code> should point to the first byte of an array of <code>xs_count</code>
unsigned integers, each of which consists of <code>x_size</code> bytes in
<code>x_endianness</code> byte order.</p>
</div>
<div class="paragraph">
<p><code>ys</code> should point to the first byte of an array of <code>xs_count</code>
unsigned integers, each of which consists of <code>y_size</code> bytes in
<code>y_endianness</code> byte order.
It is also required that
\(\mathtt{y\_size} \ge \lceil r / 8 \rceil\),
where \(r\) is the number of range bits in the key.</p>
</div>
<div class="paragraph">
<p>The key is evaluated at each domain element in the <code>xs</code> array and each
result is written to the corresponding range element in the <code>ys</code> array.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_map_eval_reduce_sum"><a class="anchor" href="#cl_pfss_map_eval_reduce_sum"></a><a class="link" href="#cl_pfss_map_eval_reduce_sum">6.18. The <code>pfss_map_eval_reduce_sum</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_map_eval_reduce_sum(
  pfss_key const * key,
  uint8_t const *  xs,
  uint32_t         xs_count,
  uint32_t         x_size,
  pfss_endianness  x_endianness,
  uint8_t *        y,
  uint32_t         y_size,
  pfss_endianness  y_endianness
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_map_eval_reduce_sum</code> function evaluates a key over a list of
domain elements and sums the resulting range elements to produce a
single range element.</p>
</div>
<div class="paragraph">
<p><code>xs</code> should point to the first byte of an array of <code>xs_count</code>
unsigned integers, each of which consists of <code>x_size</code> bytes in
<code>x_endianness</code> byte order.</p>
</div>
<div class="paragraph">
<p><code>y</code> should point to the first byte of a range element (i.e., an
unsigned integer) that consists of <code>y_size</code> bytes in <code>y_endianness</code>
byte order.
It is also required that
\(\mathtt{y\_size} \ge \lceil r / 8 \rceil\),
where \(r\) is the number of range bits in the key.</p>
</div>
<div class="paragraph">
<p>The key is evaluated at each domain element in the <code>xs</code> array, the
resulting range elements are summed modulo \(2^r\), and the sum is
written to the range element pointed to by <code>y</code>.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_eval_all"><a class="anchor" href="#cl_pfss_eval_all"></a><a class="link" href="#cl_pfss_eval_all">6.19. The <code>pfss_eval_all</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_eval_all(
  pfss_key const * key,
  uint8_t const *  xp,
  uint32_t         xp_bits,
  pfss_endianness  xp_endianness,
  uint8_t *        ys,
  uint32_t         y_size,
  pfss_endianness  y_endianness
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_eval_all</code> function evaluates a key over a (partial) grid of
domain elements to produce a (partial) grid of range elements.</p>
</div>
<div class="paragraph">
<p>First, the \(\lceil \mathtt{xp\_bits} / 8 \rceil\) bytes pointed to
by <code>xp</code> are interpreted as an unsigned integer in <code>xp_endianness</code> byte
order.
All bits of this integer are ignored except for the least significant
<code>xp_bits</code> bits, which form a value \(v\).
This value is shifted left by \(k = d - \mathtt{xp\_bits}\) bits to
form the first domain element \(x_1\) at which <code>key</code> will be
evaluated, where \(d\) is the number of domain bits in <code>key</code>.
In other words, \(x_1 = v \cdot 2^k\).
It is required that \(k \ge 0\), i.e., that
\(\mathtt{xp\_bits} \le d\).</p>
</div>
<div class="paragraph">
<p>Next, <code>key</code> is evaluated at each successive domain element up to and
including \(x_{2^k} = x_1 + 2^k - 1\), and each result is written to
a specific location in the array of bytes pointed to by <code>ys</code>.
The array of bytes is treated as an array of unsigned integers, each
consisting of <code>y_size</code> bytes in <code>y_endianness</code> byte order.
It is required that \(\mathtt{y\_size} \ge \lceil r / 8 \rceil\),
where \(r\) is the number of range bits in <code>key</code>.
The evaluation result of each \(x_i\) is written to the \(x_i\)'th
element of the array.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. </div>
<div class="content">
<div class="listingblock">
<div class="title">Program</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;cstdint&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;pfss.h&gt;
#include &lt;random&gt;
#include &lt;stdexcept&gt;

namespace {

void check_status(pfss_status const s) {
  if (s != PFSS_OK) {
    throw std::runtime_error(pfss_get_status_name(s));
  }
}

} // namespace

int main() {
  constexpr uint32_t domain_bits = 16;
  constexpr uint32_t range_bits = 32;
  constexpr uint16_t alpha = 12345;
  constexpr uint32_t beta = 67890;
  constexpr std::size_t domain_size = (std::size_t)1 &lt;&lt; domain_bits;

  // Find out how big our buffers need to be.
  uint32_t key_blob_size;
  uint32_t rand_buf_size;
  check_status(pfss_gen_sizes(domain_bits,
                              range_bits,
                              &amp;key_blob_size,
                              &amp;rand_buf_size));

  // Allocate our buffers.
  std::vector&lt;uint8_t&gt; key1_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; key2_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; rand_buf((std::size_t)rand_buf_size);

  // Fill rand_buf with random bytes. Note that std::random_device is
  // not necessarily cryptographically secure. In practice you should
  // use something with better guarantees.
  std::random_device random_device;
  for (uint8_t &amp; r : rand_buf) {
    r = (uint8_t)random_device();
  }

  // Generate the two key blobs.
  check_status(pfss_gen(domain_bits,
                        range_bits,
                        (uint8_t const *)&amp;alpha,
                        (uint32_t)sizeof(alpha),
                        PFSS_NATIVE_ENDIAN,
                        (uint8_t const *)&amp;beta,
                        (uint32_t)sizeof(beta),
                        PFSS_NATIVE_ENDIAN,
                        key1_blob.data(),
                        key2_blob.data(),
                        rand_buf.data()));

  // Parse the first key blob.
  pfss_key * key1_ptr;
  check_status(
      pfss_parse_key(&amp;key1_ptr, key1_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key1(
      key1_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Parse the second key blob.
  pfss_key * key2_ptr;
  check_status(
      pfss_parse_key(&amp;key2_ptr, key2_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key2(
      key2_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Allocate two grids.
  std::vector&lt;uint32_t&gt; ys1(domain_size);
  std::vector&lt;uint32_t&gt; ys2(domain_size);

  // Start 8 threads to evaluate the first grid. The first thread will
  // evaluate the domain elements whose bit patterns are 000x...x, the
  // second thread 001x...x, the third thread 010x...x, and so on.
  std::vector&lt;std::future&lt;void&gt;&gt; futures1;
  for (uint8_t i = 0; i != 8; ++i) {
    futures1.push_back(std::async(std::launch::async, [&amp;key1, i, &amp;ys1] {
      check_status(pfss_eval_all(key1.get(),
                                 &amp;i,
                                 3, // 2^3 = 8
                                 PFSS_NATIVE_ENDIAN,
                                 (uint8_t *)ys1.data(),
                                 sizeof(ys1[0]),
                                 PFSS_NATIVE_ENDIAN));
    }));
  }

  // Start 16 threads to evaluate the second grid. The first thread will
  // evaluate the domain elements whose bit patterns are 0000x...x, the
  // second thread 0001x...x, the third thread 0010x...x, and so on.
  std::vector&lt;std::future&lt;void&gt;&gt; futures2;
  for (uint8_t i = 0; i != 16; ++i) {
    futures2.push_back(std::async(std::launch::async, [&amp;key2, i, &amp;ys2] {
      check_status(pfss_eval_all(key2.get(),
                                 &amp;i,
                                 4, // 2^4 = 16
                                 PFSS_NATIVE_ENDIAN,
                                 (uint8_t *)ys2.data(),
                                 sizeof(ys2[0]),
                                 PFSS_NATIVE_ENDIAN));
    }));
  }

  // Wait for all threads to complete.
  for (std::future&lt;void&gt; &amp; f : futures1) {
    f.get();
  }
  for (std::future&lt;void&gt; &amp; f : futures2) {
    f.get();
  }

  // Collapse the two grids by summing all of their elements mod
  // 2^{range_bits} (2^32) to verify that we get beta (67890) as the
  // final result. Note that because the two keys came from the same
  // pfss_gen call, ys1[i] + ys2[i] should be zero mod 2^32 everywhere
  // except at alpha (12345), where it should be beta (67890).
  unsigned long ys1_sum = 0;
  unsigned long ys2_sum = 0;
  for (auto const y : ys1) {
    ys1_sum += (unsigned long)y; // naturally mod 2^n for some n &gt;= 32
  }
  for (auto const y : ys2) {
    ys2_sum += (unsigned long)y; // naturally mod 2^n for some n &gt;= 32
  }
  ys1_sum &amp;= UINT32_MAX; // mod 2^32
  ys2_sum &amp;= UINT32_MAX; // mod 2^32
  unsigned long const sum = (ys1_sum + ys2_sum) &amp; UINT32_MAX;

  // Print out the results.
  std::cout &lt;&lt; "ys1_sum = " &lt;&lt; ys1_sum &lt;&lt; "\n";
  std::cout &lt;&lt; "ys2_sum = " &lt;&lt; ys2_sum &lt;&lt; "\n";
  std::cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; "\n";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Possible output</div>
<div class="content">
<pre class="highlight"><code>ys1_sum = 3425594880
ys2_sum = 869440306
sum = 67890</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_eval_all_sum"><a class="anchor" href="#cl_pfss_eval_all_sum"></a><a class="link" href="#cl_pfss_eval_all_sum">6.20. The <code>pfss_eval_all_sum</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_eval_all_sum(
  pfss_key const * const * keys,
  uint32_t                 keys_count,
  uint8_t *                ys,
  uint32_t                 y_size,
  pfss_endianness          y_endianness,
  uint32_t                 thread_count
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_eval_all_sum</code> function evaluates multiple keys over the
complete grid of domain elements and sums the resulting grids into an
existing grid.</p>
</div>
<div class="paragraph">
<p><code>keys</code> should point to an array of <code>keys_count</code> keys.
All keys should have the same number of domain bits.
All keys should have the same number of range bits.
If <code>keys_count</code> is zero, <code>keys</code> will not be accessed but should
still be a valid pointer.</p>
</div>
<div class="paragraph">
<p><code>ys</code> should point to a complete grid of range elements, i.e., an
array of \(2^d\) unsigned integers where \(d\) is the number of
domain bits in each key.
Each unsigned integer should consist of <code>y_size</code> bytes in
<code>y_endianness</code> byte order.
<code>y_size</code> should always be positive.
If <code>keys_count</code> is zero, <code>ys</code> will not be accessed but it should
still be a valid pointer.</p>
</div>
<div class="paragraph">
<p>Each key is evaluated at all domain elements to produce an intermediate
grid, which is then summed into <code>ys</code>.</p>
</div>
<div class="paragraph">
<p><code>thread_count</code> specifies the number of threads to use to perform the
computation.
This number should always be positive.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. </div>
<div class="content">
<div class="listingblock">
<div class="title">Program</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;cstdint&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;pfss.h&gt;
#include &lt;random&gt;
#include &lt;stdexcept&gt;

namespace {

void check_status(pfss_status const s) {
  if (s != PFSS_OK) {
    throw std::runtime_error(pfss_get_status_name(s));
  }
}

} // namespace

int main() {
  constexpr uint32_t domain_bits = 16;
  constexpr uint32_t range_bits = 32;
  constexpr uint16_t alpha = 12345;
  constexpr uint32_t beta = 67890;
  constexpr std::size_t domain_size = (std::size_t)1 &lt;&lt; domain_bits;

  // Find out how big our buffers need to be.
  uint32_t key_blob_size;
  uint32_t rand_buf_size;
  check_status(pfss_gen_sizes(domain_bits,
                              range_bits,
                              &amp;key_blob_size,
                              &amp;rand_buf_size));

  // Allocate our buffers.
  std::vector&lt;uint8_t&gt; key1_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; key2_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; rand_buf((std::size_t)rand_buf_size);

  // Fill rand_buf with random bytes. Note that std::random_device is
  // not necessarily cryptographically secure. In practice you should
  // use something with better guarantees.
  std::random_device random_device;
  for (uint8_t &amp; r : rand_buf) {
    r = (uint8_t)random_device();
  }

  // Generate the two key blobs.
  check_status(pfss_gen(domain_bits,
                        range_bits,
                        (uint8_t const *)&amp;alpha,
                        (uint32_t)sizeof(alpha),
                        PFSS_NATIVE_ENDIAN,
                        (uint8_t const *)&amp;beta,
                        (uint32_t)sizeof(beta),
                        PFSS_NATIVE_ENDIAN,
                        key1_blob.data(),
                        key2_blob.data(),
                        rand_buf.data()));

  // Parse the first key blob.
  pfss_key * key1_ptr;
  check_status(
      pfss_parse_key(&amp;key1_ptr, key1_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key1(
      key1_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Parse the second key blob.
  pfss_key * key2_ptr;
  check_status(
      pfss_parse_key(&amp;key2_ptr, key2_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key2(
      key2_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Allocate one main grid initialized to all zeros.
  std::vector&lt;uint32_t&gt; ys(domain_size);

  // Use 7 threads to evaluate each key into an ephemeral grid (as if by
  // calling the pfss_eval_all function) and sum the ephemeral grids
  // into the main grid.
  std::vector&lt;pfss_key const *&gt; const keys = {key1_ptr, key2_ptr};
  check_status(pfss_eval_all_sum(keys.data(),
                                 keys.size(),
                                 (uint8_t *)ys.data(),
                                 sizeof(ys[0]),
                                 PFSS_NATIVE_ENDIAN,
                                 7));

  // Collapse the main grid by summing all of its elements mod
  // 2^{range_bits} (2^32) to verify that we get beta (67890) as the
  // final result. Note that because the two keys came from the same
  // pfss_gen call, the grid should be zero mod 2^32 everywhere except
  // at alpha (12345), where it should be beta (67890).
  unsigned long sum = 0;
  for (auto const y : ys) {
    sum += (unsigned long)y; // naturally mod 2^n for some n &gt;= 32
  }
  sum &amp;= UINT32_MAX; // mod 2^32

  // Print out the results.
  std::cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; "\n";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlight"><code>sum = 67890</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cl_pfss_eval_all_dot"><a class="anchor" href="#cl_pfss_eval_all_dot"></a><a class="link" href="#cl_pfss_eval_all_dot">6.21. The <code>pfss_eval_all_dot</code> function</a></h3>
<div class="listingblock">
<div class="title">C and C&#43;&#43;</div>
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pfss_status pfss_eval_all_dot(
  pfss_key const * const * keys,
  uint32_t                 keys_count,
  uint8_t const *          ys,
  uint32_t                 y_size,
  pfss_endianness          y_endianness,
  uint8_t *                zs,
  uint32_t                 z_size,
  pfss_endianness          z_endianness,
  uint32_t                 thread_count
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_eval_all_dot</code> function evaluates multiple keys over the
complete grid of domain elements and computes the dot product of each
resulting grid with an existing grid.</p>
</div>
<div class="paragraph">
<p><code>keys</code> should point to an array of <code>keys_count</code> keys.
All keys should have the same number of domain bits.
All keys should have the same number of range bits.
If <code>keys_count</code> is zero, <code>keys</code> will not be accessed but should
still be a valid pointer.</p>
</div>
<div class="paragraph">
<p><code>ys</code> should point to a complete grid of range elements, i.e., an
array of \(2^d\) unsigned integers where \(d\) is the number of
domain bits in each key.
Each unsigned integer should consist of <code>y_size</code> bytes in
<code>y_endianness</code> byte order.
<code>y_size</code> should always be positive.
If <code>keys_count</code> is zero, <code>ys</code> will not be accessed but it should
still be a valid pointer.</p>
</div>
<div class="paragraph">
<p><code>zs</code> should point to an array of <code>keys_count</code> unsigned integers.
Each unsigned integer should consist of <code>z_size</code> bytes in <code>z_endianness</code>
byte order.</p>
</div>
<div class="paragraph">
<p>Each key is evaluated at all domain elements to produce an intermediate
grid.
The dot product of the intermediate grid is taken with <code>ys</code>, and the
result is written to the corresponding element of <code>zs</code>.
The result is taken modulo \(2^r\) where \(r\) is the number of
range bits in each key.</p>
</div>
<div class="paragraph">
<p><code>thread_count</code> specifies the number of threads to use to perform the
computation.
This number should always be positive.</p>
</div>
<div class="paragraph">
<p>This function returns <code>PFSS_OK</code> upon success, or another status code
upon failure.
You can use the <a href="#cl_pfss_get_status_name"><code>pfss_get_status_name</code></a> function to convert the
status code into a human readable name.</p>
</div>
<div class="paragraph">
<p>Note that this function takes a <code>pfss_key const *</code>, not a <code>pfss_key *</code>.
By convention, all functions that take a <code>pfss_key const *</code> are safe to
call from multiple threads at the same time on the same key.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. </div>
<div class="content">
<div class="listingblock">
<div class="title">Program</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;cstdint&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;pfss.h&gt;
#include &lt;random&gt;
#include &lt;stdexcept&gt;

namespace {

void check_status(pfss_status const s) {
  if (s != PFSS_OK) {
    throw std::runtime_error(pfss_get_status_name(s));
  }
}

} // namespace

int main() {
  constexpr uint32_t domain_bits = 16;
  constexpr uint32_t range_bits = 32;
  constexpr uint16_t alpha = 12345;
  constexpr uint32_t beta = 1;
  constexpr std::size_t domain_size = (std::size_t)1 &lt;&lt; domain_bits;

  // Find out how big our buffers need to be.
  uint32_t key_blob_size;
  uint32_t rand_buf_size;
  check_status(pfss_gen_sizes(domain_bits,
                              range_bits,
                              &amp;key_blob_size,
                              &amp;rand_buf_size));

  // Allocate our buffers.
  std::vector&lt;uint8_t&gt; key1_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; key2_blob((std::size_t)key_blob_size);
  std::vector&lt;uint8_t&gt; rand_buf((std::size_t)rand_buf_size);

  // Fill rand_buf with random bytes. Note that std::random_device is
  // not necessarily cryptographically secure. In practice you should
  // use something with better guarantees.
  std::random_device random_device;
  for (uint8_t &amp; r : rand_buf) {
    r = (uint8_t)random_device();
  }

  // Generate the two key blobs.
  check_status(pfss_gen(domain_bits,
                        range_bits,
                        (uint8_t const *)&amp;alpha,
                        (uint32_t)sizeof(alpha),
                        PFSS_NATIVE_ENDIAN,
                        (uint8_t const *)&amp;beta,
                        (uint32_t)sizeof(beta),
                        PFSS_NATIVE_ENDIAN,
                        key1_blob.data(),
                        key2_blob.data(),
                        rand_buf.data()));

  // Parse the first key blob.
  pfss_key * key1_ptr;
  check_status(
      pfss_parse_key(&amp;key1_ptr, key1_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key1(
      key1_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Parse the second key blob.
  pfss_key * key2_ptr;
  check_status(
      pfss_parse_key(&amp;key2_ptr, key2_blob.data(), key_blob_size));
  std::unique_ptr&lt;pfss_key, void (*)(pfss_key *)&gt; const key2(
      key2_ptr,
      [](pfss_key * const k) { pfss_destroy_key(k); });

  // Allocate one main grid initialized to all zeros everywhere except
  // at alpha (12345), where it is 67890.
  std::vector&lt;uint32_t&gt; ys(domain_size);
  ys[alpha] = 67890;

  // Use 7 threads to evaluate each key into an ephemeral grid (as if by
  // calling the pfss_eval_all function) and compute the dot product of
  // each ephemeral grid with the main grid into a result vector zs.
  std::vector&lt;uint32_t&gt; zs(2);
  std::vector&lt;pfss_key const *&gt; const keys = {key1_ptr, key2_ptr};
  check_status(pfss_eval_all_dot(keys.data(),
                                 keys.size(),
                                 (uint8_t const *)ys.data(),
                                 sizeof(ys[0]),
                                 PFSS_NATIVE_ENDIAN,
                                 (uint8_t *)zs.data(),
                                 sizeof(zs[0]),
                                 PFSS_NATIVE_ENDIAN,
                                 7));

  // Sum the two results mod 2^{range_bits} (2^32) to verify that we get
  // ys[alpha] (67890) as the final result. Note that because the two
  // keys came from the same pfss_gen call and beta = 1, the two keys
  // work together to "select" the element at index alpha in ys.
  unsigned long sum = 0;
  for (auto const z : zs) {
    sum += (unsigned long)z; // naturally mod 2^n for some n &gt;= 32
  }
  sum &amp;= UINT32_MAX; // mod 2^32

  // Print out the results.
  std::cout &lt;&lt; "zs[0] = " &lt;&lt; zs[0] &lt;&lt; "\n";
  std::cout &lt;&lt; "zs[1] = " &lt;&lt; zs[1] &lt;&lt; "\n";
  std::cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; "\n";
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Possible output</div>
<div class="content">
<pre class="highlight"><code>zs[0] = 2326640992
zs[1] = 1968394194
sum = 67890</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_pfss_switch_db_rb_macro"><a class="anchor" href="#_the_pfss_switch_db_rb_macro"></a><a class="link" href="#_the_pfss_switch_db_rb_macro">6.22. The <code>PFSS_SWITCH_DB_RB</code> macro</a></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PFSS_SWITCH_DB_RB( \
    domain_bits, range_bits, template_code, standard_code)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PFSS_SWITCH_DB_RB</code> macro expands to a
<code>do { /* ... */ } while (0)</code> block of code that calls either
<code>template_code((domain_bits), (range_bits))</code> or <code>standard_code()</code>
depending on whether PFSS was compiled with template optimizations
enabled for the given <code>domain_bits</code> and <code>range_bits</code> combination via
<a href="../switch_db_rb.cfg"><code>switch_db_rb.cfg</code></a>.
<code>template_code</code> should be the name of a function-like macro that takes
two parameters.
The arguments passed to <code>template_code</code> will not actually be
<code>domain_bits</code> and <code>range_bits</code>, but rather decimal constants whose
values match <code>domain_bits</code> and <code>range_bits</code>, which allows them to be
used as template arguments in C&#43;&#43;.
<code>standard_code</code> should be the name of a function-like macro that takes
no arguments.
<code>template_code</code> and <code>standard_code</code> should each expand to a
<code>do { /* ... */ } while (0)</code> block of code.
<code>domain_bits</code> and <code>range_bits</code> will each be evaluated exactly once.</p>
</div>
<div class="paragraph">
<p>Here is an example function that determines whether PFSS was compiled
with template optimizations enabled for a given <code>domain_bits</code> and
<code>range_bits</code> combination:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">int have_template_optimizations(int domain_bits, int range_bits) {
#define T_CODE(db, rb) do { return 1; } while (0)
#define S_CODE() do { return 0; } while (0)
  PFSS_SWITCH_DB_RB(domain_bits, range_bits, T_CODE, S_CODE);
#undef S_CODE
#undef T_CODE
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_java_bindings"><a class="anchor" href="#_using_the_java_bindings"></a><a class="link" href="#_using_the_java_bindings">7. Using the Java bindings</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Java bindings are defined in the
<a href="src/java/com/stealthsoftwareinc/pfss/pfss.java"><code>src/java/com/stealthsoftwareinc/pfss/pfss.java</code></a>
file.</p>
</div>
<div class="paragraph">
<p>PFSS detects whether <code>&lt;jni.h&gt;</code> is available at <code>./configure</code> time in
order to decide whether to compile the Java bindings into <code>libpfss.so</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ ./configure
...
checking for JNI... yes
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three ways you can run <code>./configure</code> depending on your needs:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>./configure</code>: Compile the Java bindings if <code>&lt;jni.h&gt;</code> is available.</p>
</li>
<li>
<p><code>./configure --with-jni-or-die</code>: Compile the Java bindings, erroring
out if <code>&lt;jni.h&gt;</code> is not available.</p>
</li>
<li>
<p><code>./configure --without-jni</code>: Don&#8217;t compile the Java bindings.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If <code>&lt;jni.h&gt;</code> is not in your default include path, you should add any
necessary <code>-I</code> options to <code>CPPFLAGS</code> at <code>./configure</code> time.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>./configure --with-jni-or-die CPPFLAGS='-I/path/to/jni/dir'</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>./configure</code> is unexpectedly failing to detect that <code>&lt;jni.h&gt;</code> is
available, you can search for <code>JNI</code> in <code>config.log</code> to see why.
For example, here is a failure where an additional <code>-I</code> option was
necessary for <code>&lt;jni.h&gt;</code> to find a dependent header <code>"jni_md.h"</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>configure:9266: checking for JNI
configure:9337: gcc -c -g -O2 -pthread -Wall -Wextra -I/usr/lib/jvm/java-11-openjdk-amd64/include conftest.c &gt;&amp;5
In file included from conftest.c:54:0:
/usr/lib/jvm/java-11-openjdk-amd64/include/jni.h:45:10: fatal error: jni_md.h: No such file or directory
 #include "jni_md.h"
          ^~~~~~~~~~</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use the Java bindings, the <code>pfss</code> class is provided in the
<a href="src/java/com/stealthsoftwareinc/pfss/pfss.java"><code>src/java/com/stealthsoftwareinc/pfss/pfss.java</code></a>
file.
This class is a minimal wrapper of the C API that&#8217;s intended to be
included in your own Java project along with <code>libpfss.so</code>.</p>
</div>
<div class="paragraph">
<p>Pointers to arrays (including pointers to singular objects) are modeled
as Java arrays, <code>uint32_t</code> values are modeled as Java <code>int</code> values, and
opaque pointers are modeled as Java <code>long</code> values.
Every array parameter is accompanied by an index parameter that
specifies the starting point of the data in the array.</p>
</div>
<div class="paragraph">
<p>You can import the <code>pfss</code> class with
<code>import com.stealthsoftwareinc.pfss.pfss</code> and access its members with
<code>pfss.&lt;member&gt;</code>, or you can import it with
<code>import static com.stealthsoftwareinc.pfss.pfss.*</code> and access its
members directly with <code>&lt;member&gt;</code>.</p>
</div>
<div class="paragraph">
<p>For an example of using the Java bindings, see
<code>src/java/com/stealthsoftwareinc/pfss/Example.java</code>.
You can compile and run this example program as follows, where <code>&lt;D&gt;</code> is
an absolute path to a directory that contains both <code>libpfss.so</code> and
<code>libnettle.so</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>javac -sourcepath src/java src/java/com/stealthsoftwareinc/pfss/Example.java
java -cp src/java com.stealthsoftwareinc.pfss.Example [&lt;D&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>&lt;D&gt;</code> is not given, it will be taken as the current directory.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_node_js_bindings"><a class="anchor" href="#_node_js_bindings"></a><a class="link" href="#_node_js_bindings">8. Node.js bindings</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general"><a class="anchor" href="#_general"></a><a class="link" href="#_general">8.1. General</a></h3>
<div class="paragraph">
<p>The Node.js bindings are provided in the
<a href="src/node"><code>src/node</code></a>
directory, which is actually an example project.
The intent is that you can take
<a href="src/node/pfss-node.cpp"><code>pfss-node.cpp</code></a>
verbatim and adapt
<a href="src/node/binding.gyp"><code>binding.gyp</code></a>
and
<a href="src/node/package.json"><code>package.json</code></a>
into your own project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_example_project_with_docker"><a class="anchor" href="#_running_the_example_project_with_docker"></a><a class="link" href="#_running_the_example_project_with_docker">8.2. Running the example project with Docker</a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Build a distribution archive (<code>pfss-*.tar.gz</code>) by running <code>make dist</code>
(after <code>./configure</code>).</p>
</li>
<li>
<p>Copy the distribution archive into the <code>src/node</code> directory.
Make sure you have exactly one such file in that directory.
If you don&#8217;t have exactly one, the image won&#8217;t build.</p>
</li>
<li>
<p>Run <code>docker build -t pfss-node src/node</code> to build the image.</p>
</li>
<li>
<p>Run <code>docker run -i -t --rm pfss-node</code> to start a container.</p>
</li>
<li>
<p>In the container, run <code>npm install</code> followed by <code>node-gyp rebuild</code>.</p>
</li>
<li>
<p>In the container, run <code>node example.js</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_reference"><a class="anchor" href="#_reference"></a><a class="link" href="#_reference">8.3. Reference</a></h3>
<div class="sect3">
<h4 id="node_sec_pfss_reduce_sum_async"><a class="anchor" href="#node_sec_pfss_reduce_sum_async"></a><a class="link" href="#node_sec_pfss_reduce_sum_async">8.3.1. The <code>pfss_reduce_sum_async</code> function</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code><em>pfss_status</em> pfss_reduce_sum_async(
  <em>Uint32</em>           range_bits,
  <em>Uint8Array const</em> ys,
  <em>Uint32</em>           ys_index,
  <em>Uint32</em>           ys_count,
  <em>Uint32</em>           y_size,
  <em>pfss_endianness</em>  y_endianness,
  <em>Uint8Array</em>       z,
  <em>Uint32</em>           z_index,
  <em>Uint32</em>           z_size,
  <em>pfss_endianness</em>  z_endianness,
  <em>function</em>         callback
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_reduce_sum_async</code> function calls the
<a href="#node_sec_pfss_reduce_sum"><code>pfss_reduce_sum</code></a> function asynchronously
with all of the parameters except <code>callback</code>.
After the asynchronous call completes, <code>callback(s)</code> is called, where
<code>s</code> is the status code returned by the asynchronous call.
The function returns <code>PFSS_OK</code> upon success, or another status code if
the asynchronous call could not be initiated.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. A simple sum</div>
<div class="content">
<div class="paragraph">
<p>The following program uses the <code>pfss_reduce_sum_async</code> function to
compute \((0 + 1 + \ldots + 99999)\ \textrm{mod}\ 2^{32}\):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">Object.assign(global, require("bindings")("pfss"));

let ys = Uint32Array.from(Array(100000).keys());
let z = new Uint32Array(1);

let status1 = pfss_reduce_sum_async(
  ys.BYTES_PER_ELEMENT * 8, // 32
  new Uint8Array(ys.buffer),
  0,
  ys.length, // 100000
  ys.BYTES_PER_ELEMENT, // 4
  PFSS_NATIVE_ENDIAN,
  new Uint8Array(z.buffer),
  0,
  z.BYTES_PER_ELEMENT, // 4
  PFSS_NATIVE_ENDIAN,
  function(status2) {
    if (status2 == PFSS_OK) {
      console.log("z = " + z[0]);
    } else {
      console.log(pfss_get_status_name(status2));
    }
  }
);

if (status1 != PFSS_OK) {
  console.log(pfss_get_status_name(status1));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>z = 704982704</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="node_sec_pfss_map_eval_reduce_sum_async"><a class="anchor" href="#node_sec_pfss_map_eval_reduce_sum_async"></a><a class="link" href="#node_sec_pfss_map_eval_reduce_sum_async">8.3.2. The <code>pfss_map_eval_reduce_sum_async</code> function</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code><em>pfss_status</em> pfss_map_eval_reduce_sum_async(
  <em>pfss_key</em>         key,
  <em>Uint8Array const</em> xs,
  <em>Uint32</em>           xs_index,
  <em>Uint32</em>           xs_count,
  <em>Uint32</em>           x_size,
  <em>pfss_endianness</em>  x_endianness,
  <em>Uint8Array</em>       y,
  <em>Uint32</em>           y_index,
  <em>Uint32</em>           y_size,
  <em>pfss_endianness</em>  y_endianness,
  <em>function</em>         callback
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>pfss_map_eval_reduce_sum_async</code> function calls the
<a href="#node_sec_pfss_map_eval_reduce_sum"><code>pfss_map_eval_reduce_sum</code></a>
function asynchronously with all of the parameters except <code>callback</code>.
After the asynchronous call completes, <code>callback(s)</code> is called, where
<code>s</code> is the status code returned by the asynchronous call.
The function returns <code>PFSS_OK</code> upon success, or another status code if
the asynchronous call could not be initiated.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-28 01:54:27 UTC
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>